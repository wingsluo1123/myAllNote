# 二叉树

## 二叉树

### 快速写出前中后序遍历：

（借用第一题的图）
**前序：**先写1 2 ，3写远一些，2 和3空出来的位置留给2所引出的所有子树；4紧接着写在2后面，5写远一些但不超过3，4和5空出来的位置留给4所引出的子树；以此类推，得出 根的左子树总是紧接着根，左子树的子树总是在右子树的前面... ...

**中序：**建议从**最深的子树开始写**，例如 567这棵树，由于中序排列在方向上是左右关系，则写成 6 5 7，然后把这个6 5 7看作整体A，再根据24A这棵树的左右关系容易写出4 2 A，以此类推。中序讲的就是**左右关系**

**后序：**也是**建议从最深的子树开始写**，例如 567这棵树，后序是按照 6 7 5 的顺序来排列，把6 7 5 看作整体A，24A这棵树的后序是4 A 2，以此类推... ...



已知：

* 前序遍历和中序遍历
* 中序遍历和后序遍历

可以唯一确定一棵二叉树
**注意：已知前序和后序，无法确定一颗二叉树。必须已知中序遍历**

![image-20250717173056344](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250717173056344.png)

答案：D
解析：123是一棵树，245也是一棵树，567也是一棵树... ...他们的根分别是1 2 5... ...选项的意思是对于一颗三个元素的二叉树的遍历顺序。由遍历节点顺序可知，这是先压右子树，打印，再压左子树的递归（换句话说，就是 左右颠倒的中序遍历），则打印出3 1 2，那么在总的打印序列中，1 2 3按照312的顺序依次出现，不会颠倒，也就是 右子树 根 左子树。



![image-20250717180549751](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250717180549751.png)

答案：A
解析：管他几个节点，高度为5的二叉树最多有31个节点，根据顺序储存结构的保存方式，直接选A。由这道题我们还可以知道，对于ABC树，前序遍历和顺序储存的排序一样，当我们拿到一个前序遍历，可以很快判断属于B的后代为B后的空格（或者其他字母），知道遇到C 为止，以此类推。



## 线索二叉树

可以像数组（或者双向链表）一样遍历的二叉树，利用节点的空子节点来指向前驱节点和后继节点（左空子节点指向前驱，右空子节点指向后继节点）

![image-20250718114502834](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250718114502834.png)

**一个由n个节点的二叉树，那么有n+1个空节点**

新增一个空节点，无数据，使之左孩子指向A，使右孩子作为后继指针指向后继节点G（中序遍历的最后一个），再使H（中序遍历的开头）的左孩子作为前驱指针指向前驱节点——空节点。



## 哈夫曼树

早期用来发电报，减小发送的数据量大小。比如 哪个字母用的多，那么在编辑该字母的编码时尽量简短，使得在发送电报时发送的编码长度尽可能的短。

![9f26193cdba431fe9ef1b9b91ad7c99b](C:\Users\Wanxu Luo\xwechat_files\wxid_n2scnxtb3vn722_8c13\temp\RWTemp\2025-07\9e20f478899dc29eb19741386f9343c8\9f26193cdba431fe9ef1b9b91ad7c99b.jpg)

**前缀编码：**任何一个编码都不是其他编码的前缀。（可以防止多可能解读的编码）

**构造哈夫曼树：**

* 首先对元素进行排序，从小到大
* 拿出现有的排列的最小的两个元素作为左右孩子，两者相加的和作为根
* 根值按大小放入原排列中（此时原排列已经没有了刚刚的左右孩子），然后重复上述步骤

## 树与二叉树的转换

转换后使得树的**先根**遍历和**后根**遍历 与 二叉树的**前序**遍历和**中序**遍历一样

**树->二叉树：**

* 加线，在所有兄弟节点之间加一条线
* 去线，对树中的每一个节点，只保留它与第一个孩子节点的连线，删除它与其他孩子节点之间的连线
* 层次调整，以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之层次分明。注意第一个孩子时二叉树节点的左孩子。兄弟转过来的孩子是节点的右孩子

**二叉树->树：**

* 加线，若某个节点的左孩子存在，则将这个左孩子的所有右孩子节点都作为此节点的孩子，将该节点与这些右孩子节点用线连起来
* 去线，删除二叉树中所有节点与其右孩子节点的连线
* 调整，转一下

## 森林与二叉树的转换

转换后使得森林的前序遍历和中序遍历 与 二叉树的前序遍历和中序遍历一样

注意：森林没有后序遍历这一说法

**森林：**几棵树摆在一起

**森林->二叉树：**

* 先把所有树变成二叉树
* 从第二棵树开始，每棵树作为右孩子连接在前一棵树根节点上

**二叉树->森林：**

* 从根节点开始，若右孩子存在，把根与右孩子的连线断掉，分出来的子树作为第二棵树，对该树重复刚刚操作
* 把二叉树变成

![image-20250726153943192](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250726153943192.png)

选B

![image-20250726155935499](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250726155935499.png)

答案：1896
解析：关键点是 兄弟转过来的孩子是右孩子。并且要合理构图，图要自己想出来

![image-20250726162147588](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250726162147588.png)

疑问：森林的树的深度只能是两层吗 答：不是
疑问：那为什么我把第三棵树画成深度为3节点数也是3的树，结果就不对了

![image-20250727163951820](C:\Users\Wanxu Luo\AppData\Roaming\Typora\typora-user-images\image-20250727163951820.png)

第一问：对于一颗正则k叉树，满足n=km+1。可以这么理解：想象一片森林，每棵树都是深度为2的正则k叉树，每棵树的节点数都是n=k+1，假设有x棵树，则森林共有n=xk+x个节点，现在如果把其中一颗树的根节点和另一棵树的其中一个孩子重合，此时森林共有n=xk+x-1个节点，重复这个动作，当最终重合到只剩下一颗树的时候，那么森林的节点数为n=xk+x-(x-1)=xk+1，当x为m的时候，也就是n=mk+1。