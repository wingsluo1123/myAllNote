```c++
#include <iostream>
#include <cmath>
#include <stack>
#include <queue>
#define elementType char
using namespace std;

typedef struct treeNode {
	treeNode* lc;
	treeNode* rc;
	int lt;//用于表明孩子节点是前驱后继还是真的是孩子
	int rt;
	elementType data;
}treeNode;

typedef treeNode* treeThread;

char str[] = "ABDH##I##EJ###CF##G##";
int idx = 0;
treeThread pv;
//创建树
void createTree(treeThread* t) {
	char ch;
	ch = str[idx++];
	if (ch == '#') { *t = NULL; }
	else {
		*t = new treeNode; (*t)->data = ch; createTree(&(*t)->lc);
		if ((*t)->lc != NULL) { (*t)->lt = 0; }
		createTree(&(*t)->rc);
		if ((*t)->rc != NULL) { (*t)->rt = 0; }
	}
}

//前序遍历
void preOrder(treeNode*& t) {
	if (t == NULL) { return; }
	cout << t->data << endl;
	preOrder(t->lc);
	preOrder(t->rc);
}

//中序遍历
void inOrder(treeNode*& t) {
	if (t == NULL) { return; }
	inOrder(t->lc);
	cout << t->data << endl;
	inOrder(t->rc);
}

//后续遍历
void postOrder(treeNode*& t) {
	if (t == NULL) { return; }
	postOrder(t->lc);
	postOrder(t->rc);
	cout << t->data << endl;
}

//前序遍历具体线索化
void preThreading(treeThread t) {
	if (t != NULL) {
		if (t->lc == NULL) { t->lt = 1; t->lc = pv; }
		if (pv->rc == NULL) { pv->rt = 1; pv->rc = t; }
		pv = t;
		if (t->lc != NULL && t->lt == 0/*防止循环*/) { preThreading(t->lc); }
		if (t->rc != NULL && t->rt == 0) { preThreading(t->rc); }
	}
}

//前序遍历线索化
void preOrderThreading(treeThread* head, treeThread t) {
	//头节点
	*head = new treeNode;
	(*head)->lt = 0;
	(*head)->rt = 1;
	(*head)->lc = (*head);

	if (!(t == NULL)) {
		(*head)->lc = t;
		pv = *head;
		preThreading(t);
		//最后一个节点线索化
		pv->rc = *head;
		pv->rt = 1;
		//头节点右孩子指向最后一个节点
		(*head)->rc = pv;
	}
}

//前序遍历线索化的遍历
void preOrderThreadPrint(treeThread head) {
	treeThread tt = (head)->lc;
	while (tt != head) {
		cout << tt->data << endl;
		if (tt->lt == 0) {
			tt = tt->lc;
		}
		else {
			tt = tt->rc;
		}
	}

}

//中序遍历具体线索化
void inThreading(treeThread t) {
	if (t != NULL) {
		inThreading(t->lc);
		if (t->lc == NULL) { t->lt = 1; t->lc = pv; }
		if (pv->rc == NULL) { pv->rt = 1; pv->rc = t; }
		pv = t;
		inThreading(t->rc);
	}
}

//中序遍历线索化
void inOrderThreading(treeThread* head, treeThread t) {
	//头节点
	*head = new treeNode;
	(*head)->lt = 0;
	(*head)->rt = 1;
	(*head)->lc = (*head);

	if (!(t == NULL)) {
		(*head)->lc = t;
		pv = *head;
		inThreading(t);
		//最后一个节点线索化
		pv->rc = *head;
		pv->rt = 1;
		//头节点右孩子指向最后一个节点
		(*head)->rc = pv;
	}
}

//中序遍历线索化的遍历
void inOrderThreadPrint(treeThread head) {
	treeThread tt = (head)->lc;
	while (!(tt->lt)) { tt = tt->lc; }
	while (!(tt == head)) {
		cout << tt->data << endl;
		if (tt->rt == 1) {
			tt = tt->rc;
		}
		else {
			tt = tt->rc;
			while (!(tt->lt)) { tt = tt->lc; }
		}
	}
}

//后序遍历具体线索化
void postThreading(treeThread t) {
	if (t == NULL) return;
	postThreading(t->lc);
	postThreading(t->rc);
	if (t->lc == NULL) { t->lt = 1; t->lc = pv; }
	if (pv->rc == NULL) { pv->rt = 1; pv->rc = t; }
	pv = t;
}

//后序遍历线索化
void postOrderThreading(treeThread* head, treeThread t) {
	//头节点
	*head = new treeNode;
	(*head)->lt = 0;
	(*head)->rt = 1;
	(*head)->lc = (*head);

	if (!(t == NULL)) {
		(*head)->lc = t;
		pv = *head;
		postThreading(t);
		//最后一个节点线索化
		pv->rc = *head;
		pv->rt = 1;
		//头节点右孩子指向最后一个节点
		(*head)->rc = pv;
	}
}

//后序遍历线索化的遍历
void postOrderThreadPrint(treeThread head) {
	// 不会写 呜呜呜呜呜T 。T
}

//非递归前序遍历 不会写 不用掌握
void iterPreOrder(stack<treeNode*> s, treeNode*& t) {
	/*while (s.empty() == 1 || t != NULL) {
		while (!t == NULL) {
			cout << t->data << endl;
			s.push(t);
			t = t->lc;
		}
		t = s.top();
		t = t->rc;
	}*/
}

//层序遍历
int lapbylap(treeThread root) {
	if (root == NULL) { return 0; }
	int depth = 0;
	queue<treeThread> q;
	q.push(root);
	while (!q.empty()) {
		int count = q.size();
		while (count) {
			treeThread cur = q.front();
			q.pop();
			if (cur->lc != NULL) { q.push(cur->lc); }
			if (cur->rc != NULL) { q.push(cur->rc); }
			count--;
		}
		depth++;
	}
	return depth;
}

//计算带权路径长度wpl 层序遍历版本
int calDisRight(treeThread root) {
	if (root == NULL)return 0;
	int res = 0;
	int depth = 0;
	queue<treeThread> q;
	q.push(root);
	while (!q.empty()) {
		int count = q.size();
		while (count) {
			treeThread cur = q.front();
			q.pop();
			if (cur->lc == NULL && cur->rc == NULL) { res += cur->data * depth; }
			if (cur->lc != NULL) { q.push(cur->lc); }
			if (cur->rc != NULL) { q.push(cur->rc); }
			count--;
		}
		depth++;
	}
	return res;
}

//计算wpl的优雅递归版本
int cal(treeThread t, int d) {
	int cur_res = 0;
	if (t == NULL) { return cur_res; }
	if (t->lc == NULL && t->rc == NULL) { cur_res = t->data * d; }
	if (t->lc != NULL) { cur_res += cal(t->lc, d + 1); }
	if (t->rc != NULL) { cur_res += cal(t->rc, d + 1); }
	return cur_res;
}


int main() {
	treeThread head;
	treeThread t;
	createTree(&t);
	/*inOrder(t);
	inOrderThreading(&head, t); cout << endl;
	inOrderThreadPrint(head);*/

	/*preOrder(t);
	preOrderThreading(&head, t); cout << endl;
	preOrderThreadPrint(head);*/

	/*postOrder(t);
	cout << endl;
	postOrderThreading(&head, t); 
	postOrderThreadPrint(head);*/

	cout << cal(t, 0) << endl;
	cout << calDisRight(t) << endl;
}

```

